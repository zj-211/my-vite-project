//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion

//#region ../node_modules/.pnpm/@pengzhanbo+utils@2.1.0/node_modules/@pengzhanbo/utils/dist/index.mjs
function toString(s) {
	return Object.prototype.toString.call(s);
}
function getTypeName(s) {
	return s === null ? "null" : typeof s === "object" || typeof s === "function" ? toString(s).slice(8, -1).toLowerCase() : typeof s;
}
function isPrimitive(v) {
	return v === null || typeof v !== "object" && typeof v !== "function";
}
function isBoolean(v) {
	return typeof v === "boolean";
}
function isFunction(v) {
	return typeof v === "function";
}
function isString(v) {
	return typeof v === "string";
}
function isPlainObject(v) {
	return getTypeName(v) === "object";
}
function isArray(v) {
	return Array.isArray(v);
}
function isEmptyObject(v) {
	if (!isPlainObject(v)) return false;
	for (const _ in v) return false;
	return true;
}
function isTypedArray(v) {
	return ArrayBuffer.isView(v) && !(v instanceof DataView);
}
function toArray(v) {
	if (v === null || v === void 0) return [];
	if (isArray(v)) return v;
	return [v];
}
function uniq(v) {
	return Array.from(new Set(v));
}
function sortBy(array, cb) {
	if (array.length === 0) return [];
	return array.sort((a, b) => {
		const s1 = cb(a);
		const s2 = cb(b);
		return s1 > s2 ? 1 : s2 > s1 ? -1 : 0;
	});
}
function hasOwn(obj, key) {
	return obj === null ? false : Object.prototype.hasOwnProperty.call(obj, key);
}
function deepCloneImpl(valueToClone, objectToClone, stack = /* @__PURE__ */ new Map()) {
	if (isPrimitive(valueToClone)) return valueToClone;
	/* istanbul ignore if -- @preserve */
	if (stack.has(valueToClone)) return stack.get(valueToClone);
	if (Array.isArray(valueToClone)) {
		const result = Array.from({ length: valueToClone.length });
		stack.set(valueToClone, result);
		for (let i = 0; i < valueToClone.length; i++) result[i] = deepCloneImpl(valueToClone[i], objectToClone, stack);
		if (Object.hasOwn(valueToClone, "index")) result.index = valueToClone.index;
		if (Object.hasOwn(valueToClone, "input")) result.input = valueToClone.input;
		return result;
	}
	if (valueToClone instanceof Date) return new Date(valueToClone.getTime());
	if (valueToClone instanceof RegExp) {
		const result = new RegExp(valueToClone.source, valueToClone.flags);
		result.lastIndex = valueToClone.lastIndex;
		return result;
	}
	if (valueToClone instanceof Map) {
		const result = /* @__PURE__ */ new Map();
		stack.set(valueToClone, result);
		for (const [key, value] of valueToClone) result.set(key, deepCloneImpl(value, objectToClone, stack));
		return result;
	}
	if (valueToClone instanceof Set) {
		const result = /* @__PURE__ */ new Set();
		stack.set(valueToClone, result);
		for (const value of valueToClone) result.add(deepCloneImpl(value, objectToClone, stack));
		return result;
	}
	if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) return valueToClone.subarray();
	if (isTypedArray(valueToClone)) {
		const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
		stack.set(valueToClone, result);
		for (let i = 0; i < valueToClone.length; i++) result[i] = deepCloneImpl(valueToClone[i], objectToClone, stack);
		return result;
	}
	if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) return valueToClone.slice(0);
	if (valueToClone instanceof DataView) {
		const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
		stack.set(valueToClone, result);
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	if (typeof File !== "undefined" && valueToClone instanceof File) {
		const result = new File([valueToClone], valueToClone.name, { type: valueToClone.type });
		stack.set(valueToClone, result);
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	if (valueToClone instanceof Blob) {
		const result = new Blob([valueToClone], { type: valueToClone.type });
		stack.set(valueToClone, result);
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	if (valueToClone instanceof Error) {
		const result = new valueToClone.constructor(valueToClone.message, { cause: valueToClone.cause });
		stack.set(valueToClone, result);
		if (hasOwn(valueToClone, "name")) result.name = valueToClone.name;
		result.stack = valueToClone.stack;
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	/* istanbul ignore if -- @preserve */
	if (typeof valueToClone === "object" && valueToClone !== null) {
		const result = Object.create(Object.getPrototypeOf(valueToClone));
		stack.set(valueToClone, result);
		copyProperties(result, valueToClone, objectToClone, stack);
		return result;
	}
	/* istanbul ignore next -- @preserve */
	return valueToClone;
}
function copyProperties(target, source, objectToClone = target, stack) {
	const keys = [...Object.keys(source), ...getSymbols(source)];
	for (let i = 0; i < keys.length; i++) {
		const key = keys[i];
		const descriptor = Object.getOwnPropertyDescriptor(target, key);
		if (descriptor == null || descriptor.writable) target[key] = deepCloneImpl(source[key], objectToClone, stack);
	}
}
function getSymbols(object) {
	return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
}
function deepClone(source) {
	return deepCloneImpl(source, source, /* @__PURE__ */ new Map());
}
function deepEqual(v1, v2) {
	const type1 = getTypeName(v1);
	const type2 = getTypeName(v2);
	if (type1 !== type2) return false;
	if (type1 === "array") {
		if (v1.length !== v2.length) return false;
		return v1.every((item, index) => deepEqual(item, v2[index]));
	}
	if (type1 === "object") {
		const keys1 = Object.keys(v1);
		if (keys1.length !== Object.keys(v2).length) return false;
		return keys1.every((key) => deepEqual(v1[key], v2[key]));
	}
	return Object.is(v1, v2);
}
function random(...args) {
	let min, max, float;
	if (args.length === 1) {
		min = 0;
		max = args[0];
		float = false;
	} else if (typeof args[1] === "number") {
		min = args[0];
		max = args[1];
		float = !!args[2];
	} else {
		min = 0;
		max = args[0];
		float = !!args[1];
	}
	const num = Math.random() * (max - min) + min;
	return float ? num : Math.floor(num);
}
async function sleep(ms, callback) {
	return new Promise((resolve) => setTimeout(async () => {
		await callback?.();
		resolve();
	}, ms));
}
function promiseParallel(promises, concurrency = Number.POSITIVE_INFINITY) {
	promises = Array.from(promises);
	let current = 0;
	const result = [];
	let resolvedCount = 0;
	const len = promises.length;
	return new Promise((resolve, reject) => {
		function next() {
			const index = current++;
			const promise = promises[index];
			Promise.resolve(isFunction(promise) ? promise() : promise).then((res) => {
				result[index] = res;
				if (++resolvedCount === len) resolve(result);
				if (current < len) next();
			}).catch((reason) => reject(reason));
		}
		for (let i = 0; i < concurrency && i < len; i++) next();
	});
}
function timestamp() {
	return +Date.now();
}

//#endregion
Object.defineProperty(exports, '__toESM', {
  enumerable: true,
  get: function () {
    return __toESM;
  }
});
Object.defineProperty(exports, 'deepClone', {
  enumerable: true,
  get: function () {
    return deepClone;
  }
});
Object.defineProperty(exports, 'deepEqual', {
  enumerable: true,
  get: function () {
    return deepEqual;
  }
});
Object.defineProperty(exports, 'isArray', {
  enumerable: true,
  get: function () {
    return isArray;
  }
});
Object.defineProperty(exports, 'isBoolean', {
  enumerable: true,
  get: function () {
    return isBoolean;
  }
});
Object.defineProperty(exports, 'isEmptyObject', {
  enumerable: true,
  get: function () {
    return isEmptyObject;
  }
});
Object.defineProperty(exports, 'isFunction', {
  enumerable: true,
  get: function () {
    return isFunction;
  }
});
Object.defineProperty(exports, 'isPlainObject', {
  enumerable: true,
  get: function () {
    return isPlainObject;
  }
});
Object.defineProperty(exports, 'isString', {
  enumerable: true,
  get: function () {
    return isString;
  }
});
Object.defineProperty(exports, 'promiseParallel', {
  enumerable: true,
  get: function () {
    return promiseParallel;
  }
});
Object.defineProperty(exports, 'random', {
  enumerable: true,
  get: function () {
    return random;
  }
});
Object.defineProperty(exports, 'sleep', {
  enumerable: true,
  get: function () {
    return sleep;
  }
});
Object.defineProperty(exports, 'sortBy', {
  enumerable: true,
  get: function () {
    return sortBy;
  }
});
Object.defineProperty(exports, 'timestamp', {
  enumerable: true,
  get: function () {
    return timestamp;
  }
});
Object.defineProperty(exports, 'toArray', {
  enumerable: true,
  get: function () {
    return toArray;
  }
});
Object.defineProperty(exports, 'uniq', {
  enumerable: true,
  get: function () {
    return uniq;
  }
});